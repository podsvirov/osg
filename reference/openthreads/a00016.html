<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.10"/>
<title>OpenThreads: OpenThreads::Thread Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">OpenThreads
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.10 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="inherits.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="a00027.html">OpenThreads</a></li><li class="navelem"><a class="el" href="a00016.html">Thread</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="a00045.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">OpenThreads::Thread Class Reference<span class="mlabels"><span class="mlabel">abstract</span></span></div>  </div>
</div><!--header-->
<div class="contents">

<p>This class provides an object-oriented thread interface.  
 <a href="a00016.html#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a1f57fed98f49a387ae1dd3e0cc185e8a"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00016.html#a1f57fed98f49a387ae1dd3e0cc185e8a">ThreadPriority</a> { <br />
&#160;&#160;<a class="el" href="a00016.html#a1f57fed98f49a387ae1dd3e0cc185e8aaca626a35b29da730ae163f8667276485">THREAD_PRIORITY_MAX</a>, 
<a class="el" href="a00016.html#a1f57fed98f49a387ae1dd3e0cc185e8aa9eea97f93edb239ad8a345fff4738515">THREAD_PRIORITY_HIGH</a>, 
<a class="el" href="a00016.html#a1f57fed98f49a387ae1dd3e0cc185e8aa602b81da7585b77b237381fbc95e2982">THREAD_PRIORITY_NOMINAL</a>, 
<a class="el" href="a00016.html#a1f57fed98f49a387ae1dd3e0cc185e8aa648c3a9cf6ccc3564c50df7150ceee6c">THREAD_PRIORITY_LOW</a>, 
<br />
&#160;&#160;<a class="el" href="a00016.html#a1f57fed98f49a387ae1dd3e0cc185e8aaa650066dc1919eb45e2ff21cfb95fa41">THREAD_PRIORITY_MIN</a>, 
<a class="el" href="a00016.html#a1f57fed98f49a387ae1dd3e0cc185e8aa04fd8e4a307e9ba44a526c8f092e5c5a">THREAD_PRIORITY_DEFAULT</a>
<br />
 }<tr class="memdesc:a1f57fed98f49a387ae1dd3e0cc185e8a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enumerated Type for thread priority.  <a href="a00016.html#a1f57fed98f49a387ae1dd3e0cc185e8a">More...</a><br /></td></tr>
<tr class="separator:a1f57fed98f49a387ae1dd3e0cc185e8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</td></tr>
<tr class="memitem:a40f88ee2a59fb412061db2d7970e579b"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00016.html#a40f88ee2a59fb412061db2d7970e579b">ThreadPolicy</a> { <a class="el" href="a00016.html#a40f88ee2a59fb412061db2d7970e579ba0ab427d0611058159c030233a9f7b0e6">THREAD_SCHEDULE_FIFO</a>, 
<a class="el" href="a00016.html#a40f88ee2a59fb412061db2d7970e579bae5a4ca7586e8941a6eaa0f6a760fe8e0">THREAD_SCHEDULE_ROUND_ROBIN</a>, 
<a class="el" href="a00016.html#a40f88ee2a59fb412061db2d7970e579baed3ce4d10db48030ec2a2ae2696baaaf">THREAD_SCHEDULE_TIME_SHARE</a>, 
<a class="el" href="a00016.html#a40f88ee2a59fb412061db2d7970e579ba8d77c442e1a8559d99c351b4283387c5">THREAD_SCHEDULE_DEFAULT</a>
 }<tr class="memdesc:a40f88ee2a59fb412061db2d7970e579b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enumerated Type for thread scheduling policy.  <a href="a00016.html#a40f88ee2a59fb412061db2d7970e579b">More...</a><br /></td></tr>
<tr class="separator:a40f88ee2a59fb412061db2d7970e579b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a6bc90253917b28b50c2647203dd2ae5a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00016.html#a6bc90253917b28b50c2647203dd2ae5a">Thread</a> ()</td></tr>
<tr class="memdesc:a6bc90253917b28b50c2647203dd2ae5a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor.  <a href="#a6bc90253917b28b50c2647203dd2ae5a">More...</a><br /></td></tr>
<tr class="separator:a6bc90253917b28b50c2647203dd2ae5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2926edc9f776621253c389d58bd695b"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00016.html#ae2926edc9f776621253c389d58bd695b">~Thread</a> ()</td></tr>
<tr class="memdesc:ae2926edc9f776621253c389d58bd695b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor.  <a href="#ae2926edc9f776621253c389d58bd695b">More...</a><br /></td></tr>
<tr class="separator:ae2926edc9f776621253c389d58bd695b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62b30f90878282381a5fc13e7ce6b3a1"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00016.html#a62b30f90878282381a5fc13e7ce6b3a1">getThreadId</a> ()</td></tr>
<tr class="memdesc:a62b30f90878282381a5fc13e7ce6b3a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a unique thread id.  <a href="#a62b30f90878282381a5fc13e7ce6b3a1">More...</a><br /></td></tr>
<tr class="separator:a62b30f90878282381a5fc13e7ce6b3a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af607d54c7c72922687e7ed0c6ff3bc09"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00016.html#af607d54c7c72922687e7ed0c6ff3bc09">getProcessId</a> ()</td></tr>
<tr class="memdesc:af607d54c7c72922687e7ed0c6ff3bc09"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the thread's process id.  <a href="#af607d54c7c72922687e7ed0c6ff3bc09">More...</a><br /></td></tr>
<tr class="separator:af607d54c7c72922687e7ed0c6ff3bc09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae52eaf0475bc84991cc9f96d64783b84"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00016.html#ae52eaf0475bc84991cc9f96d64783b84">start</a> ()</td></tr>
<tr class="memdesc:ae52eaf0475bc84991cc9f96d64783b84"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start the thread.  <a href="#ae52eaf0475bc84991cc9f96d64783b84">More...</a><br /></td></tr>
<tr class="separator:ae52eaf0475bc84991cc9f96d64783b84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a856e61d61aec17cef517a24e542b8778"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00016.html#a856e61d61aec17cef517a24e542b8778">startThread</a> ()</td></tr>
<tr class="separator:a856e61d61aec17cef517a24e542b8778"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a989e6a1153973a7d68c423892f9022c5"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00016.html#a989e6a1153973a7d68c423892f9022c5">testCancel</a> ()</td></tr>
<tr class="memdesc:a989e6a1153973a7d68c423892f9022c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test the cancel state of the thread.  <a href="#a989e6a1153973a7d68c423892f9022c5">More...</a><br /></td></tr>
<tr class="separator:a989e6a1153973a7d68c423892f9022c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe4a808c444f7548520680e6bfa1dbfc"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00016.html#abe4a808c444f7548520680e6bfa1dbfc">cancel</a> ()</td></tr>
<tr class="memdesc:abe4a808c444f7548520680e6bfa1dbfc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cancel the thread.  <a href="#abe4a808c444f7548520680e6bfa1dbfc">More...</a><br /></td></tr>
<tr class="separator:abe4a808c444f7548520680e6bfa1dbfc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2cc88b654a3ad4a5819def841cdf4614"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00016.html#a2cc88b654a3ad4a5819def841cdf4614">setSchedulePriority</a> (<a class="el" href="a00016.html#a1f57fed98f49a387ae1dd3e0cc185e8a">ThreadPriority</a> priority)</td></tr>
<tr class="memdesc:a2cc88b654a3ad4a5819def841cdf4614"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the thread's schedule priority.  <a href="#a2cc88b654a3ad4a5819def841cdf4614">More...</a><br /></td></tr>
<tr class="separator:a2cc88b654a3ad4a5819def841cdf4614"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9243e10f7dcad7b5f478c8af439fb276"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00016.html#a9243e10f7dcad7b5f478c8af439fb276">getSchedulePriority</a> ()</td></tr>
<tr class="memdesc:a9243e10f7dcad7b5f478c8af439fb276"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the thread's schedule priority (if able)  <a href="#a9243e10f7dcad7b5f478c8af439fb276">More...</a><br /></td></tr>
<tr class="separator:a9243e10f7dcad7b5f478c8af439fb276"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69641fb3ee2b57d3180fbc14608447f8"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00016.html#a69641fb3ee2b57d3180fbc14608447f8">setSchedulePolicy</a> (<a class="el" href="a00016.html#a40f88ee2a59fb412061db2d7970e579b">ThreadPolicy</a> policy)</td></tr>
<tr class="memdesc:a69641fb3ee2b57d3180fbc14608447f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the thread's scheduling policy (if able)  <a href="#a69641fb3ee2b57d3180fbc14608447f8">More...</a><br /></td></tr>
<tr class="separator:a69641fb3ee2b57d3180fbc14608447f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea5d04ad5853479e6e078b46a0e98d50"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00016.html#aea5d04ad5853479e6e078b46a0e98d50">getSchedulePolicy</a> ()</td></tr>
<tr class="memdesc:aea5d04ad5853479e6e078b46a0e98d50"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the thread's policy (if able)  <a href="#aea5d04ad5853479e6e078b46a0e98d50">More...</a><br /></td></tr>
<tr class="separator:aea5d04ad5853479e6e078b46a0e98d50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3eb85b3440b099ea8447e6f8755aa830"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00016.html#a3eb85b3440b099ea8447e6f8755aa830">setStackSize</a> (size_t size)</td></tr>
<tr class="memdesc:a3eb85b3440b099ea8447e6f8755aa830"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the thread's desired stack size (in bytes).  <a href="#a3eb85b3440b099ea8447e6f8755aa830">More...</a><br /></td></tr>
<tr class="separator:a3eb85b3440b099ea8447e6f8755aa830"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab931488a56f81dfbdfe176ff86eacbc3"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00016.html#ab931488a56f81dfbdfe176ff86eacbc3">getStackSize</a> ()</td></tr>
<tr class="memdesc:ab931488a56f81dfbdfe176ff86eacbc3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the thread's desired stack size.  <a href="#ab931488a56f81dfbdfe176ff86eacbc3">More...</a><br /></td></tr>
<tr class="separator:ab931488a56f81dfbdfe176ff86eacbc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e8df0a910c9929182fb7fb31f57ce4f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00016.html#a4e8df0a910c9929182fb7fb31f57ce4f">printSchedulingInfo</a> ()</td></tr>
<tr class="memdesc:a4e8df0a910c9929182fb7fb31f57ce4f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print the thread's scheduling information to stdout.  <a href="#a4e8df0a910c9929182fb7fb31f57ce4f">More...</a><br /></td></tr>
<tr class="separator:a4e8df0a910c9929182fb7fb31f57ce4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2e01b8769557110f11f6fbfa5b5aba6"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00016.html#ac2e01b8769557110f11f6fbfa5b5aba6">detach</a> ()</td></tr>
<tr class="memdesc:ac2e01b8769557110f11f6fbfa5b5aba6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Detach the thread from the calling process.  <a href="#ac2e01b8769557110f11f6fbfa5b5aba6">More...</a><br /></td></tr>
<tr class="separator:ac2e01b8769557110f11f6fbfa5b5aba6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab451f90cde2c3f87f8dc2c9a5faad979"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00016.html#ab451f90cde2c3f87f8dc2c9a5faad979">join</a> ()</td></tr>
<tr class="memdesc:ab451f90cde2c3f87f8dc2c9a5faad979"><td class="mdescLeft">&#160;</td><td class="mdescRight">Join the calling process with the thread.  <a href="#ab451f90cde2c3f87f8dc2c9a5faad979">More...</a><br /></td></tr>
<tr class="separator:ab451f90cde2c3f87f8dc2c9a5faad979"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71634250a1e70b4396400cfa011dff18"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00016.html#a71634250a1e70b4396400cfa011dff18">setCancelModeDisable</a> ()</td></tr>
<tr class="memdesc:a71634250a1e70b4396400cfa011dff18"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disable thread cancellation altogether.  <a href="#a71634250a1e70b4396400cfa011dff18">More...</a><br /></td></tr>
<tr class="separator:a71634250a1e70b4396400cfa011dff18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a270bb39ee3c65b87d4016809e32de737"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00016.html#a270bb39ee3c65b87d4016809e32de737">setCancelModeAsynchronous</a> ()</td></tr>
<tr class="memdesc:a270bb39ee3c65b87d4016809e32de737"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mark the thread to cancel asynchronously on <a class="el" href="a00016.html#abe4a808c444f7548520680e6bfa1dbfc" title="Cancel the thread. ">Thread::cancel()</a>.  <a href="#a270bb39ee3c65b87d4016809e32de737">More...</a><br /></td></tr>
<tr class="separator:a270bb39ee3c65b87d4016809e32de737"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc485fe54a15b8a445725f838193158d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00016.html#afc485fe54a15b8a445725f838193158d">setCancelModeDeferred</a> ()</td></tr>
<tr class="memdesc:afc485fe54a15b8a445725f838193158d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mark the thread to cancel at the earliest convenience on <a class="el" href="a00016.html#abe4a808c444f7548520680e6bfa1dbfc" title="Cancel the thread. ">Thread::cancel()</a> (This is the default)  <a href="#afc485fe54a15b8a445725f838193158d">More...</a><br /></td></tr>
<tr class="separator:afc485fe54a15b8a445725f838193158d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96d8f223f11c3a71f1785a2112051633"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00016.html#a96d8f223f11c3a71f1785a2112051633">isRunning</a> ()</td></tr>
<tr class="memdesc:a96d8f223f11c3a71f1785a2112051633"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query the thread's running status.  <a href="#a96d8f223f11c3a71f1785a2112051633">More...</a><br /></td></tr>
<tr class="separator:a96d8f223f11c3a71f1785a2112051633"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb802d904cca9e3206149a9efe1f83e4"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00016.html#afb802d904cca9e3206149a9efe1f83e4">run</a> ()=0</td></tr>
<tr class="memdesc:afb802d904cca9e3206149a9efe1f83e4"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="a00016.html" title="This class provides an object-oriented thread interface. ">Thread</a>'s run method.  <a href="#afb802d904cca9e3206149a9efe1f83e4">More...</a><br /></td></tr>
<tr class="separator:afb802d904cca9e3206149a9efe1f83e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3bebbad70a956a47e30737298becc51f"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00016.html#a3bebbad70a956a47e30737298becc51f">cancelCleanup</a> ()</td></tr>
<tr class="memdesc:a3bebbad70a956a47e30737298becc51f"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="a00016.html" title="This class provides an object-oriented thread interface. ">Thread</a>'s cancel cleanup routine, called upon <a class="el" href="a00016.html#abe4a808c444f7548520680e6bfa1dbfc" title="Cancel the thread. ">cancel()</a>, after the cancellation has taken place, but before the thread exits completely.  <a href="#a3bebbad70a956a47e30737298becc51f">More...</a><br /></td></tr>
<tr class="separator:a3bebbad70a956a47e30737298becc51f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27e0b385c49d1f57e2ecb8363d3641d1"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00016.html#a27e0b385c49d1f57e2ecb8363d3641d1">getImplementation</a> ()</td></tr>
<tr class="separator:a27e0b385c49d1f57e2ecb8363d3641d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91efa532982ea5a89a485a802617b2e2"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00016.html#a91efa532982ea5a89a485a802617b2e2">setProcessorAffinity</a> (unsigned int cpunum)</td></tr>
<tr class="memdesc:a91efa532982ea5a89a485a802617b2e2"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="a00016.html" title="This class provides an object-oriented thread interface. ">Thread</a>'s processor affinity method.  <a href="#a91efa532982ea5a89a485a802617b2e2">More...</a><br /></td></tr>
<tr class="separator:a91efa532982ea5a89a485a802617b2e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a1369402cdf698506e1304723cb08057d"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00016.html#a1369402cdf698506e1304723cb08057d">SetConcurrency</a> (int concurrencyLevel)</td></tr>
<tr class="memdesc:a1369402cdf698506e1304723cb08057d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the concurrency level for a running application.  <a href="#a1369402cdf698506e1304723cb08057d">More...</a><br /></td></tr>
<tr class="separator:a1369402cdf698506e1304723cb08057d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adee75f3a133fc285b25e723cfa2ed6eb"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00016.html#adee75f3a133fc285b25e723cfa2ed6eb">GetConcurrency</a> ()</td></tr>
<tr class="memdesc:adee75f3a133fc285b25e723cfa2ed6eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the concurrency level for a running application.  <a href="#adee75f3a133fc285b25e723cfa2ed6eb">More...</a><br /></td></tr>
<tr class="separator:adee75f3a133fc285b25e723cfa2ed6eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1760ce9beb19bcf222ab8ac86b6c58d6"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="a00016.html">Thread</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00016.html#a1760ce9beb19bcf222ab8ac86b6c58d6">CurrentThread</a> ()</td></tr>
<tr class="memdesc:a1760ce9beb19bcf222ab8ac86b6c58d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a pointer to the current running thread.  <a href="#a1760ce9beb19bcf222ab8ac86b6c58d6">More...</a><br /></td></tr>
<tr class="separator:a1760ce9beb19bcf222ab8ac86b6c58d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af988ef894b393b5dbc250c21cea0ae2d"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00016.html#af988ef894b393b5dbc250c21cea0ae2d">Init</a> ()</td></tr>
<tr class="memdesc:af988ef894b393b5dbc250c21cea0ae2d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize Threading in a program.  <a href="#af988ef894b393b5dbc250c21cea0ae2d">More...</a><br /></td></tr>
<tr class="separator:af988ef894b393b5dbc250c21cea0ae2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76a5bba0a8865c880f984c6df383eb7d"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00016.html#a76a5bba0a8865c880f984c6df383eb7d">YieldCurrentThread</a> ()</td></tr>
<tr class="memdesc:a76a5bba0a8865c880f984c6df383eb7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Yield the processor.  <a href="#a76a5bba0a8865c880f984c6df383eb7d">More...</a><br /></td></tr>
<tr class="separator:a76a5bba0a8865c880f984c6df383eb7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff79998cc4b7360d3d80120c8fb88b61"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="a00016.html#a1f57fed98f49a387ae1dd3e0cc185e8a">ThreadPriority</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00016.html#aff79998cc4b7360d3d80120c8fb88b61">GetMasterPriority</a> ()</td></tr>
<tr class="memdesc:aff79998cc4b7360d3d80120c8fb88b61"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method will return the ThreadPriority of the master process.  <a href="#aff79998cc4b7360d3d80120c8fb88b61">More...</a><br /></td></tr>
<tr class="separator:aff79998cc4b7360d3d80120c8fb88b61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19f97253ae90bb5e137cf96d82023220"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00016.html#a19f97253ae90bb5e137cf96d82023220">microSleep</a> (unsigned int microsec)</td></tr>
<tr class="memdesc:a19f97253ae90bb5e137cf96d82023220"><td class="mdescLeft">&#160;</td><td class="mdescRight">microSleep method, equivalent to the posix usleep(microsec).  <a href="#a19f97253ae90bb5e137cf96d82023220">More...</a><br /></td></tr>
<tr class="separator:a19f97253ae90bb5e137cf96d82023220"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a2a1b7d1a2228897da066a0bd92589ba9"><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00016.html#a2a1b7d1a2228897da066a0bd92589ba9">ThreadPrivateActions</a></td></tr>
<tr class="memdesc:a2a1b7d1a2228897da066a0bd92589ba9"><td class="mdescLeft">&#160;</td><td class="mdescRight">The Private Actions class is allowed to operate on private data.  <a href="#a2a1b7d1a2228897da066a0bd92589ba9">More...</a><br /></td></tr>
<tr class="separator:a2a1b7d1a2228897da066a0bd92589ba9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>This class provides an object-oriented thread interface. </p>
</div><h2 class="groupheader">Member Enumeration Documentation</h2>
<a class="anchor" id="a40f88ee2a59fb412061db2d7970e579b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="a00016.html#a40f88ee2a59fb412061db2d7970e579b">OpenThreads::Thread::ThreadPolicy</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enumerated Type for thread scheduling policy. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="a40f88ee2a59fb412061db2d7970e579ba0ab427d0611058159c030233a9f7b0e6"></a>THREAD_SCHEDULE_FIFO&#160;</td><td class="fielddoc">
<p>First in, First out scheduling. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a40f88ee2a59fb412061db2d7970e579bae5a4ca7586e8941a6eaa0f6a760fe8e0"></a>THREAD_SCHEDULE_ROUND_ROBIN&#160;</td><td class="fielddoc">
<p>Round-robin scheduling (LINUX_DEFAULT) </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a40f88ee2a59fb412061db2d7970e579baed3ce4d10db48030ec2a2ae2696baaaf"></a>THREAD_SCHEDULE_TIME_SHARE&#160;</td><td class="fielddoc">
<p>Time-share scheduling (IRIX DEFAULT) </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a40f88ee2a59fb412061db2d7970e579ba8d77c442e1a8559d99c351b4283387c5"></a>THREAD_SCHEDULE_DEFAULT&#160;</td><td class="fielddoc">
<p>Default scheduling. </p>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="a1f57fed98f49a387ae1dd3e0cc185e8a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="a00016.html#a1f57fed98f49a387ae1dd3e0cc185e8a">OpenThreads::Thread::ThreadPriority</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enumerated Type for thread priority. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="a1f57fed98f49a387ae1dd3e0cc185e8aaca626a35b29da730ae163f8667276485"></a>THREAD_PRIORITY_MAX&#160;</td><td class="fielddoc">
<p>The maximum possible priority. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a1f57fed98f49a387ae1dd3e0cc185e8aa9eea97f93edb239ad8a345fff4738515"></a>THREAD_PRIORITY_HIGH&#160;</td><td class="fielddoc">
<p>A high (but not max) setting. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a1f57fed98f49a387ae1dd3e0cc185e8aa602b81da7585b77b237381fbc95e2982"></a>THREAD_PRIORITY_NOMINAL&#160;</td><td class="fielddoc">
<p>An average priority. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a1f57fed98f49a387ae1dd3e0cc185e8aa648c3a9cf6ccc3564c50df7150ceee6c"></a>THREAD_PRIORITY_LOW&#160;</td><td class="fielddoc">
<p>A low (but not min) setting. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a1f57fed98f49a387ae1dd3e0cc185e8aaa650066dc1919eb45e2ff21cfb95fa41"></a>THREAD_PRIORITY_MIN&#160;</td><td class="fielddoc">
<p>The miniumum possible priority. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a1f57fed98f49a387ae1dd3e0cc185e8aa04fd8e4a307e9ba44a526c8f092e5c5a"></a>THREAD_PRIORITY_DEFAULT&#160;</td><td class="fielddoc">
<p>Priority scheduling default. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a6bc90253917b28b50c2647203dd2ae5a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">OpenThreads::Thread::Thread </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructor. </p>

</div>
</div>
<a class="anchor" id="ae2926edc9f776621253c389d58bd695b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual OpenThreads::Thread::~Thread </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destructor. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="abe4a808c444f7548520680e6bfa1dbfc"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int OpenThreads::Thread::cancel </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Cancel the thread. </p>
<p>Equivalent to SIGKILL.</p>
<dl class="section return"><dt>Returns</dt><dd>0 if normal, -1 if errno set, errno code otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a3bebbad70a956a47e30737298becc51f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void OpenThreads::Thread::cancelCleanup </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="a00016.html" title="This class provides an object-oriented thread interface. ">Thread</a>'s cancel cleanup routine, called upon <a class="el" href="a00016.html#abe4a808c444f7548520680e6bfa1dbfc" title="Cancel the thread. ">cancel()</a>, after the cancellation has taken place, but before the thread exits completely. </p>
<p>This method should be used to repair parts of the thread's data that may have been damaged by a pre-mature cancel. No-op by default. </p>

</div>
</div>
<a class="anchor" id="a1760ce9beb19bcf222ab8ac86b6c58d6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="a00016.html">Thread</a>* OpenThreads::Thread::CurrentThread </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a pointer to the current running thread. </p>

</div>
</div>
<a class="anchor" id="ac2e01b8769557110f11f6fbfa5b5aba6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OpenThreads::Thread::detach </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Detach the thread from the calling process. </p>
<dl class="section return"><dt>Returns</dt><dd>0 if normal, -1 if errno set, errno code otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="adee75f3a133fc285b25e723cfa2ed6eb"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int OpenThreads::Thread::GetConcurrency </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the concurrency level for a running application. </p>
<p>In this case, a return code of 0 means that the application is in default mode. A return code of -1 means that the application is incapable of setting an arbitrary concurrency, because it is a one-to-one execution model (sprocs, linuxThreads) </p>

</div>
</div>
<a class="anchor" id="a27e0b385c49d1f57e2ecb8363d3641d1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void* OpenThreads::Thread::getImplementation </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="aff79998cc4b7360d3d80120c8fb88b61"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="a00016.html#a1f57fed98f49a387ae1dd3e0cc185e8a">ThreadPriority</a> OpenThreads::Thread::GetMasterPriority </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This method will return the ThreadPriority of the master process. </p>
<p>(ie, the one calling the thread-&gt;<a class="el" href="a00016.html#ae52eaf0475bc84991cc9f96d64783b84" title="Start the thread. ">start()</a> methods for the first time) The method will almost certainly return <a class="el" href="a00016.html#a1f57fed98f49a387ae1dd3e0cc185e8aa04fd8e4a307e9ba44a526c8f092e5c5a" title="Priority scheduling default. ">Thread::THREAD_PRIORITY_DEFAULT</a> if <a class="el" href="a00016.html#af988ef894b393b5dbc250c21cea0ae2d" title="Initialize Threading in a program. ">Init()</a> has not been called.</p>
<dl class="section return"><dt>Returns</dt><dd>the <a class="el" href="a00016.html#a1f57fed98f49a387ae1dd3e0cc185e8a" title="Enumerated Type for thread priority. ">Thread::ThreadPriority</a> of the master thread. </dd></dl>

</div>
</div>
<a class="anchor" id="af607d54c7c72922687e7ed0c6ff3bc09"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t OpenThreads::Thread::getProcessId </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the thread's process id. </p>
<p>This is the pthread_t or pid_t value depending on the threading model being used.</p>
<dl class="section return"><dt>Returns</dt><dd>thread process id. </dd></dl>

</div>
</div>
<a class="anchor" id="aea5d04ad5853479e6e078b46a0e98d50"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OpenThreads::Thread::getSchedulePolicy </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the thread's policy (if able) </p>
<dl class="section note"><dt>Note</dt><dd>setting the environment variable OUTPUT_THREADLIB_SCHEDULING_INFO will output scheduling information for each thread to stdout.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>policy if normal, -1 if errno set, errno code otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a9243e10f7dcad7b5f478c8af439fb276"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OpenThreads::Thread::getSchedulePriority </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the thread's schedule priority (if able) </p>
<dl class="section note"><dt>Note</dt><dd>setting the environment variable OUTPUT_THREADLIB_SCHEDULING_INFO will output scheduling information for each thread to stdout.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>0 if normal, -1 if errno set, errno code otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="ab931488a56f81dfbdfe176ff86eacbc3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t OpenThreads::Thread::getStackSize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the thread's desired stack size. </p>
<dl class="section return"><dt>Returns</dt><dd>the thread's stack size. 0 indicates that the stack size has either not yet been initialized, or not yet been specified by the application. </dd></dl>

</div>
</div>
<a class="anchor" id="a62b30f90878282381a5fc13e7ce6b3a1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OpenThreads::Thread::getThreadId </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a unique thread id. </p>
<p>This id is monotonically increasing.</p>
<dl class="section return"><dt>Returns</dt><dd>a unique thread identifier </dd></dl>

</div>
</div>
<a class="anchor" id="af988ef894b393b5dbc250c21cea0ae2d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void OpenThreads::Thread::Init </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initialize Threading in a program. </p>
<p>This method must be called before you can do any threading in a program. </p>

</div>
</div>
<a class="anchor" id="a96d8f223f11c3a71f1785a2112051633"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool OpenThreads::Thread::isRunning </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Query the thread's running status. </p>
<dl class="section return"><dt>Returns</dt><dd>true if running, false if not. </dd></dl>

</div>
</div>
<a class="anchor" id="ab451f90cde2c3f87f8dc2c9a5faad979"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OpenThreads::Thread::join </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Join the calling process with the thread. </p>
<dl class="section return"><dt>Returns</dt><dd>0 if normal, -1 if errno set, errno code otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a19f97253ae90bb5e137cf96d82023220"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int OpenThreads::Thread::microSleep </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>microsec</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>microSleep method, equivalent to the posix usleep(microsec). </p>
<p>This is not strictly thread API but is used so often with threads. It's basically UNIX usleep. Parameter is number of microseconds we current thread to sleep. Returns 0 on success, non-zero on failure (UNIX errno or GetLastError() will give detailed description. </p>

</div>
</div>
<a class="anchor" id="a4e8df0a910c9929182fb7fb31f57ce4f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OpenThreads::Thread::printSchedulingInfo </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Print the thread's scheduling information to stdout. </p>

</div>
</div>
<a class="anchor" id="afb802d904cca9e3206149a9efe1f83e4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void OpenThreads::Thread::run </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="a00016.html" title="This class provides an object-oriented thread interface. ">Thread</a>'s run method. </p>
<p>Must be implemented by derived classes. This is where the action happens. </p>

</div>
</div>
<a class="anchor" id="a270bb39ee3c65b87d4016809e32de737"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OpenThreads::Thread::setCancelModeAsynchronous </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Mark the thread to cancel asynchronously on <a class="el" href="a00016.html#abe4a808c444f7548520680e6bfa1dbfc" title="Cancel the thread. ">Thread::cancel()</a>. </p>
<p>(May not be available with process-level implementations).</p>
<dl class="section return"><dt>Returns</dt><dd>0 if normal, -1 if errno set, errno code otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="afc485fe54a15b8a445725f838193158d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OpenThreads::Thread::setCancelModeDeferred </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Mark the thread to cancel at the earliest convenience on <a class="el" href="a00016.html#abe4a808c444f7548520680e6bfa1dbfc" title="Cancel the thread. ">Thread::cancel()</a> (This is the default) </p>
<dl class="section return"><dt>Returns</dt><dd>0 if normal, -1 if errno set, errno code otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a71634250a1e70b4396400cfa011dff18"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OpenThreads::Thread::setCancelModeDisable </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Disable thread cancellation altogether. </p>
<p><a class="el" href="a00016.html#abe4a808c444f7548520680e6bfa1dbfc" title="Cancel the thread. ">Thread::cancel()</a> has no effect.</p>
<dl class="section return"><dt>Returns</dt><dd>0 if normal, -1 if errno set, errno code otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a1369402cdf698506e1304723cb08057d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int OpenThreads::Thread::SetConcurrency </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>concurrencyLevel</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the concurrency level for a running application. </p>
<p>This method only has effect if the pthreads thread model is being used, and then only when that model is many-to-one (eg. irix). in other cases it is ignored. The concurrency level is only a <em>hint</em> as to the number of execution vehicles to use, the actual implementation may do anything it wants. Setting the value to 0 returns things to their default state.</p>
<dl class="section return"><dt>Returns</dt><dd>previous concurrency level, -1 indicates no-op. </dd></dl>

</div>
</div>
<a class="anchor" id="a91efa532982ea5a89a485a802617b2e2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OpenThreads::Thread::setProcessorAffinity </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>cpunum</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="a00016.html" title="This class provides an object-oriented thread interface. ">Thread</a>'s processor affinity method. </p>
<p>This binds a thread to a processor whenever possible. This call must be made before <a class="el" href="a00016.html#ae52eaf0475bc84991cc9f96d64783b84" title="Start the thread. ">start()</a> or <a class="el" href="a00016.html#a856e61d61aec17cef517a24e542b8778">startThread()</a> and has no effect after the thread has been running. In the pthreads implementation, this is only implemented on sgi, through a pthread extension. On other pthread platforms this is ignored. Returns 0 on success, implementation's error on failure, or -1 if ignored. </p>

</div>
</div>
<a class="anchor" id="a69641fb3ee2b57d3180fbc14608447f8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OpenThreads::Thread::setSchedulePolicy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00016.html#a40f88ee2a59fb412061db2d7970e579b">ThreadPolicy</a>&#160;</td>
          <td class="paramname"><em>policy</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the thread's scheduling policy (if able) </p>
<dl class="section note"><dt>Note</dt><dd>On some implementations (notably IRIX Sprocs &amp; LinuxThreads) The policy may prohibit the use of SCHEDULE_ROUND_ROBIN and SCHEDULE_FIFO policies - due to their real-time nature, and the danger of deadlocking the machine when used as super-user. In such cases, the command is a no-op.</dd>
<dd>
setting the environment variable OUTPUT_THREADLIB_SCHEDULING_INFO will output scheduling information for each thread to stdout.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>0 if normal, -1 if errno set, errno code otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a2cc88b654a3ad4a5819def841cdf4614"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OpenThreads::Thread::setSchedulePriority </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00016.html#a1f57fed98f49a387ae1dd3e0cc185e8a">ThreadPriority</a>&#160;</td>
          <td class="paramname"><em>priority</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the thread's schedule priority. </p>
<p>This is a complex method. Beware of thread priorities when using a many-to-many kernel entity implemenation (such as IRIX pthreads). If one is not careful to manage the thread priorities, a priority inversion deadlock can easily occur (Although the <a class="el" href="a00007.html" title="This class provides an object-oriented thread mutex interface. ">OpenThreads::Mutex</a> &amp; <a class="el" href="a00003.html" title="This class provides an object-oriented thread barrier interface. ">OpenThreads::Barrier</a> constructs have been designed with this scenario in mind). Unless you have explicit need to set the schedule priorities for a given task, it is best to leave them alone.</p>
<dl class="section note"><dt>Note</dt><dd>some implementations (notably LinuxThreads and IRIX Sprocs) only allow you to decrease thread priorities dynamically. Thus, a lower priority thread will not allow it's priority to be raised on the fly.</dd>
<dd>
setting the environment variable OUTPUT_THREADLIB_SCHEDULING_INFO will output scheduling information for each thread to stdout.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>0 if normal, -1 if errno set, errno code otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a3eb85b3440b099ea8447e6f8755aa830"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OpenThreads::Thread::setStackSize </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the thread's desired stack size (in bytes). </p>
<p>This method is an attribute of the thread and must be called <em>before</em> the <a class="el" href="a00016.html#ae52eaf0475bc84991cc9f96d64783b84" title="Start the thread. ">start()</a> method is invoked.</p>
<dl class="section note"><dt>Note</dt><dd>a return code of 13 (EACESS) means that the thread stack size can no longer be changed.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>0 if normal, -1 if errno set, errno code otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="ae52eaf0475bc84991cc9f96d64783b84"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OpenThreads::Thread::start </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Start the thread. </p>
<p>This method will configure the thread, set it's priority, and spawn it.</p>
<dl class="section note"><dt>Note</dt><dd>if the stack size specified setStackSize is smaller than the smallest allowable stack size, the threads stack size will be set to the minimum allowed, and may be retrieved via the <a class="el" href="a00016.html#ab931488a56f81dfbdfe176ff86eacbc3" title="Get the thread&#39;s desired stack size. ">getStackSize()</a></dd></dl>
<dl class="section return"><dt>Returns</dt><dd>0 if normal, -1 if errno set, errno code otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a856e61d61aec17cef517a24e542b8778"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OpenThreads::Thread::startThread </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a989e6a1153973a7d68c423892f9022c5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OpenThreads::Thread::testCancel </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Test the cancel state of the thread. </p>
<p>If the thread has been canceled this method will cause the thread to exit now. This method operates on the calling thread.</p>
<p>Returns 0 if normal, -1 if called from a thread other that this. </p>

</div>
</div>
<a class="anchor" id="a76a5bba0a8865c880f984c6df383eb7d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int OpenThreads::Thread::YieldCurrentThread </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Yield the processor. </p>
<dl class="section note"><dt>Note</dt><dd>This method operates on the calling process. And is equivalent to calling sched_yield().</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>0 if normal, -1 if errno set, errno code otherwise. </dd></dl>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a class="anchor" id="a2a1b7d1a2228897da066a0bd92589ba9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend class ThreadPrivateActions</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The Private Actions class is allowed to operate on private data. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>OpenThreads/<a class="el" href="a00026.html">Thread</a></li>
</ul>
</div><!-- contents -->
<hr>
<table border="0"><tr><td>
  <img src="osg32-32.png" alt="osg logo" />
</td><td>
  <address><small>Generated at Wed Nov 11 2015 22:28:36 for the <a href="http://www.openscenegraph.org/">OpenThreads</a>
by <a href="http://www.doxygen.org">doxygen</a> 1.8.10.</small></address>
<!-- Dimitri van Heesch's e-mail address removed, lest he get messages on the OpenSceneGraph -->
</td></tr></table>
</body>
</html>
